<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html lang="en">
<head>
  <meta name="generator" content=
  "HTML Tidy for Mac OS X (vers 31 October 2006 - Apple Inc. build 13), see www.w3.org">

  <title>Final Program for 2010 Workshop on Scheme and Functional Programming</title>
  <meta http-equiv="Content-Type" content=
  "text/html; charset=us-ascii">
  <meta http-equiv="Content-Type" content=
  "text/html; charset=us-ascii">
  <link href="column.css" rel="stylesheet" type="text/css">
</head>

<body>
  <div id="content">
    <div id="header">
      <center>
        <div class="whited">
          <h1>Final Program for 2010 Workshop on Scheme and Functional Programming</h1>
        </div>
      </center>
    </div>

    <div class="colmask leftmenu">
      <div class="colleft">
        <div class="col1">

<h2>Final Program</h2>

<hr size="5">

<P>
<DIV ALIGN="LEFT">
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT" COLSPAN=2><B>Saturday, August 21</B></TD>
</TR>
<TR><TD ALIGN="RIGHT">8:15</TD>
<TD ALIGN="LEFT" VALIGN="TOP"><EM>On-site registration and breakfast</EM></TD>
</TR>
<TR><TD ALIGN="LEFT" COLSPAN=2><B>Invited Talk</B></TD>
</TR>
<TR><TD ALIGN="RIGHT">9:00</TD>
<TD ALIGN="LEFT" VALIGN="TOP"><B>Eager parsing and user interaction with call/cc</B></TD>
</TR>
<TR><TD ALIGN="RIGHT">&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP">Olin Shivers;<br> Northeastern University</TD>
</TR>
<TR><TD ALIGN="RIGHT">10:00</TD>
<TD ALIGN="LEFT" VALIGN="TOP"><B>Break</B></TD>
</TR>
<TR><TD ALIGN="LEFT" COLSPAN=2><B>Session 1</B></TD>
</TR>
<TR><TD ALIGN="RIGHT">10:30</TD>
<TD ALIGN="LEFT" VALIGN="TOP"><a href="prashanth-tobin-hochstadt-presentation.pdf"><B>Functional Data Structures for Typed Racket</B></a></TD>
</TR>
<TR><TD ALIGN="RIGHT">&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP">Hari Prashanth K R and Sam Tobin-Hochstadt;<br> Northeastern University</TD>
</TR>
<TR><TD ALIGN="RIGHT">11:00</TD>
<TD ALIGN="LEFT" VALIGN="TOP"><a href="hsu-presentation.pdf"><B>Implementing User-level Value-weak Hashtables</B></a></TD>
</TR>
<TR><TD ALIGN="RIGHT">&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP">Aaron W. Hsu;<br> Indiana University</TD>
</TR>
<TR><TD ALIGN="RIGHT">11:30</TD>
<TD ALIGN="LEFT" VALIGN="TOP"><B>Break</B></TD>
</TR>
<TR><TD ALIGN="LEFT" COLSPAN=2><B>Session 2</B></TD>
</TR>
<TR><TD ALIGN="RIGHT">12:00</TD>
<TD ALIGN="LEFT" VALIGN="TOP"><a href="earl-might-van-horn-presentation.pdf"><B>Pushdown Control-Flow Analysis of Higher-Order Programs</B></a></TD>
</TR>
<TR><TD ALIGN="RIGHT">&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP">Christopher Earl<sup>1</sup>, Matthew Might<sup>1</sup>, and David Van Horn <sup>2</sup>;<br>
    <sup>1</sup>University of Utah, <sup>2</sup>Northeastern University</TD>
</TR>
<TR><TD ALIGN="RIGHT">12:30</TD>
<TD ALIGN="LEFT" VALIGN="TOP"><B>Lightning talks</B></TD>
</TR>
<TR><TD ALIGN="RIGHT">&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP"><EM>Speakers to be announced at the workshop</EM></TD>
</TR>
<TR><TD ALIGN="RIGHT">12:45</TD>
<TD ALIGN="LEFT" VALIGN="TOP"><B>Lunch break</B></TD>
</TR>
<TR><TD ALIGN="LEFT" COLSPAN=2><B>Session 3</B></TD>
</TR>
<TR><TD ALIGN="RIGHT">14:00</TD>
<TD ALIGN="LEFT" VALIGN="TOP"><a href="marceau-fisler-krishnamurthi-presentation.pdf "><B>Measuring the Effectiveness of Error Messages Designed for Novice Programmers</B></a></TD>
</TR>
<TR><TD ALIGN="RIGHT">&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP">Guillaume Marceau<sup>1</sup>, Kathi Fisler<sup>1</sup>, and Shriram Krishnamurthi<sup>2</sup>;<br>
    <sup>1</sup>Worcester Polytechnic Institute, <sup>2</sup>Brown University</TD>
</TR>
<TR><TD ALIGN="RIGHT">14:30</TD>
<TD ALIGN="LEFT" VALIGN="TOP"><a href="cartier-guillemette-presentation.pdf "><B>JazzScheme: Evolution of a Lisp-Based Development System</B></a></TD>
</TR>
<TR><TD ALIGN="RIGHT">&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP">Guillaume Cartier and Louis-Julien Guillemette;<br> Auphelia Technologies Inc.</TD>
</TR>
<TR><TD ALIGN="RIGHT">15:00</TD>
<TD ALIGN="LEFT" VALIGN="TOP"><B>Break</B></TD>
</TR>
<TR><TD ALIGN="LEFT" COLSPAN=2><B>Session 4</B></TD>
</TR>
<TR><TD ALIGN="RIGHT">15:30</TD>
<TD ALIGN="LEFT" VALIGN="TOP"><a href="barland-findler-flatt-presentation.pdf"><B>The Design of a Functional Image Library</B></a></TD>
</TR>
<TR><TD ALIGN="RIGHT">&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP">Ian Barland<sup>1</sup>, Robert Findler<sup>2</sup>, and Matthew Flatt<sup>3</sup>;<br>
    <sup>1</sup>Radford University, <sup>2</sup>Northwestern University, <sup>3</sup>University of Utah</TD>
</TR>
<TR><TD ALIGN="RIGHT">16:00</TD>
<TD ALIGN="LEFT" VALIGN="TOP"><a href="keep-dybvig-presentation.pdf"><B>Enabling cross-library optimization and compile-time error checking in the presence of procedural macros</B></a></TD>
</TR>
<TR><TD ALIGN="RIGHT">&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP">Andrew Keep and R. Kent Dybvig;<br>
    Indiana University</TD>
</TR>
<TR><TD ALIGN="RIGHT">16:30</TD>
<TD ALIGN="LEFT" VALIGN="TOP"><B>Break</B></TD>
</TR>
<TR><TD ALIGN="LEFT" COLSPAN=2><B>Session 5</B></TD>
</TR>
<TR><TD ALIGN="RIGHT">17:00</TD>
<TD ALIGN="LEFT" VALIGN="TOP"><a href="latendresse-presentation.pdf"><B>Guiding Requirements for the Ongoing Scheme Standardization Process</B></a></TD>
</TR>
<TR><TD ALIGN="RIGHT">&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP">Mario Latendresse;<br>
    SRI International</TD>
</TR>
<TR><TD ALIGN="RIGHT">17:20</TD>
<TD ALIGN="LEFT" VALIGN="TOP"><B>Lightning talks</B></TD>
</TR>
<TR><TD ALIGN="RIGHT">&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP"><EM>Speakers to be announced at the workshop</EM></TD>
</TR>
</TABLE>
</DIV>

<hr size="5">

<P>
<DIV ALIGN="LEFT">
<TABLE CELLPADDING=3>
<TR><TD ALIGN="LEFT" COLSPAN=2><B>Sunday, August 22</B></TD>
</TR>
<TR><TD ALIGN="RIGHT">8:15</TD>
<TD ALIGN="LEFT" VALIGN="TOP"><EM>Breakfast</EM></TD>
</TR>
<TR><TD ALIGN="LEFT" COLSPAN=2><B>Invited Talk</B></TD>
</TR>
<TR><TD ALIGN="RIGHT">9:00</TD>
<TD ALIGN="LEFT" VALIGN="TOP"><a href="sfp2010-contracts-in-racket.pdf"><B>Contracts in Racket</B></a></TD>
</TR>
<TR><TD ALIGN="RIGHT">&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP">Robert Findler;<br> Northwestern University</TD>
</TR>
<TR><TD ALIGN="RIGHT">10:00</TD>
<TD ALIGN="LEFT" VALIGN="TOP"><B>Break</B></TD>
</TR>
<TR><TD ALIGN="LEFT" COLSPAN=2><B>Session 6</B></TD>
</TR>
<TR><TD ALIGN="RIGHT">10:30</TD>
<TD ALIGN="LEFT" VALIGN="TOP"><B>Report by the Scheme Language Steering Committee and</B></TD>
</TR>
<TR><TD ALIGN="RIGHT">&nbsp;</TD>
<TD ALIGN="LEFT" VALIGN="TOP"><B>report by the Scheme Language Working Groups</B></TD>

</TR>
<TR><TD ALIGN="RIGHT">12:00</TD>
<TD ALIGN="LEFT" VALIGN="TOP"><B>Closing</B></TD>
</TR>
</TABLE>
</DIV>

<hr size="5">

          <h2>Abstracts</h2>

<div>
<h3>Eager parsing and user interaction with call/cc</h3>
<h4>Olin Shivers</h4>
<p>
Many s-expressions have the pleasant property of being syntactically
self-terminating: we know when we come to the right parenthesis at the
end of a list that the list is complete. Old (but advanced) Lisp systems
such as Maclisp and the Lisp Machine exploited this fact by interleaving
the parser and the interactive "rubout" handler: a call to the reader
completes as soon as the parser has consumed a complete s-expression
<em>without the user needing to input a following separator character</em>. Yet
the user is also able to correct erroneous, incomplete input by "backing
up" with the delete key and re-entering corrected text.
</p>

<p>
Implementing such an input facility turns out to be a task for which
Scheme has just the right tools: call/cc and other higher-order control
operators. I will show how to use these operators to implement a reader
that is eager, yet interactively permits correction. Although the
parsing and error-correction <em>functionality</em> is interleaved, the <em>code</em>
is not. The implementation is quite modular: the reader is a standard,
off-the-shelf recursive-descent parser, written with no concern for
error correction; the error-correction code works with any parser that
needs no more than one character of lookahead.
</p>

<p>
The talk will show the development of real code, giving a demonstration
of how Scheme's sophisticated control operators are put to work in a
real systems-programming context.
</p>
</div>


<div>
<h3>Functional Data Structures for Typed Racket</h3>
<h4>Hari Prashanth KR and Sam Tobin-Hochstadt</h4>
<p>
Scheme provides excellent language support for programming in a
functional style, but little in the way of library support.  In this
paper, we present a comprehensive library of functional data
structures, drawing from several sources.  We have implemented the
library in Typed Scheme, a typed variant of PLT Scheme, allowing us to
maintain the type invariants of the original definitions.
</p>
</div>


<div>
<h3>Implementing User-level Value-weak Hashtables</h3>
<h4>Aaron Hsu</h4>
<p>
Value weak hashtables retain only weak references to the
values associated with either a strongly or weakly referenced
key. Value-weak hashtables automatically remove entries
with invalid weak references, which occurs when the
collector reclaims a weakly referenced value. Value-weak
hashtables provide a convenient way to automatically
manage secondary information that does not need to exist
once the primary object no longer exists. However, most
Scheme implementations do not provide value-weak
hashtables by default in their base library. Key-weak
hashtables are more common. This paper presents an user-
level technique for implementing value-weak hashtables that
relies on features commonly found or that could be
implemented in most implementations. This makes value-
weak hashtables a practical reality for most Scheme users
without requiring additional work on the implementation
code itself. Programmers may, therefore, utilize value-weak
hashtables in code that targets a wider range of
implementations.
</p>
</div>


<div>
<h3>Pushdown Control-Flow Analysis of Higher-Order Programs</h3>
<h4>Christopher Earl, Matthew Might, and David Van Horn</h4>
<p>
We present push-down control-flow analysis, a novel method for
analyzing higher-order control-flow.  As its name suggests, push-down
control-flow analysis replaces the finite-state machine underlying
classical CFAs with a push-down system.  The infinite state-space
afforded by a push-down system makes it both more precise and more
powerful than classical control-flow analysis.  The push-down stack
adds extra precision by perfectly matching returns to call sites.
We discover push-down control-flow analysis as an abstract
interpretation of a CESK machine with an unbounded stack.  To prove
computability, we transform the abstracted CESK machine into a
push-down automaton (PDA), and then reduce control-flow analysis to
deciding the non-emptiness of a language derived from the PDA's
language.  From there, we refine the algorithm, dropping its
time-complexity from doubly exponential, to best-case exponential, to
worst-case exponential, to polynomial.  In the end, we are left with an efficient, polyvariant framework for
control-flow analysis that can compute push-down generalizations of
the classical finite-state control-flow analysis, e.g. push-down 0CFA,
push-down k-CFA and push-down poly/CFA.
</p>
</div>


<div>
<h3>Measuring the Effectiveness of Error Messages Designed for Novice Programmers</h3>
<h4>Guillaume Marceau, Kathi Fisler, and Shriram Krishnamurthi</h4>
<p>
Good error messages are critical for novice programmers.  Many projects attempt to rewrite expert-level error messages in terms suitable for novices.  DrScheme's language levels provide a powerful alternative through which error messages are customized to pedagogically-inspired language subsets.  Despite this, many novices still struggle to work effectively with DrScheme's error messages.  To better understand why, we have begun using human-factors research methods to explore the effectiveness of DrScheme's error messages.  Unlike existing work in this area, we study messages at a fine-grained level by analyzing the edits students make in response to various classes of errors.  Our results point to several shortcomings in DrScheme's current treatment of errors; many of these should apply to other languages.  This paper describes our methodology, presents initial findings, and recommends new approaches to presenting errors to novices.
</p>
</div>


<div>
<h3>JazzScheme: Evolution of a Lisp-Based Development System</h3>
<h4>Guillaume Cartier and Louis-Julien Guillemette</h4>
<p>
This article introduces JazzScheme, a development system based on
extending the Scheme programming language and the Gambit system.
JazzScheme includes a module system, hygienic macros, object-oriented
programming, a full featured cross-platform application framework, a
sophisticated programmable IDE and a build system that creates executable
binaries for Mac OS X, Windows and Linux. JazzScheme has been used for more
than 10 years to develop commercial software.
</p>
</div>


<div>
<h3>The Design of a Functional Image Library</h3>
<h4>Ian Barland, Robert Findler, and Matthew Flatt</h4>
<p>
We report on experience implementing a functional image library
designed for use in an introductory programming course. 
Designing the library revealed subtle aspects of image manipulation,
and led to some interesting design decisions.  Our new
library improves on the earlier Racket library by adding
rotation and having a significantly faster implementation
of equal?.
</p>
</div>


<div>
<h3>Enabling cross-library optimization and compile-time error checking in the presence of procedural macros</h3>
<h4>Andrew Keep	and R. Kent Dybvig</h4>
<p>
Libraries and top-level programs are the basic units of portable code in the language defined by the Revised 6 Report on Scheme.  As such, they are naturally treated as compilation units, with source optimization and certain forms of compile-time error checking occurring within but not across library and program boundaries.  This paper describes a library-group form that can be used to turn a group of libraries and optionally a top-level program into a single compilation unit, allowing whole programs to be constructed from groups of independent pieces and enabling cross-library optimization and compile-time error checking.  The paper also describes the implementation, which is challenging partly because of the need to support the use of one library's run-time exports when another library in the same group is compiled.  The implementation does so without expanding any library in the group more than once, since doing so is expensive in some cases and, more importantly, semantically unsound in general.  While described in the context of Scheme, the techniques presented in this paper are applicable to any language that supports both procedural macros and libraries, and might be adaptable to dependently typed languages or template meta-programming languages that provide full compile-time access to the source language.
</p>
</div>


<div>
<h3>Guiding Requirements for the Ongoing Scheme Standardization Process</h3>
<h4>Mario Latendresse</h4>
<p>
The Scheme standardization process has produced several Scheme revisions, the most recent one being R6RS. The R7RS standardization process is underway with an amended charter. The new charter has introduced two language levels, Small Scheme and Large Scheme, succinctly described as "lightweight" and "heavyweight", respectively. We analyze this new charter and propose some mod- ifications to it that we believe would help the standardization of Scheme, and in particular steer it towards greater use by the software developer community. We suggest that the Steering Committee establishes guiding requirements for the two Scheme levels. We discuss some examples of concrete guiding requirements to include in the standardization process for maintenance and debugging. We also discuss the need for an additional general principle for Small Scheme and suggest that, besides the general principle of a small language specification, the notion of efficiency of execution is also at the core of Small Scheme.
</p>
</div>

<div>
<h3>Contracts in Racket</h3>
<h4>Robert Findler</h4>
<p>
Adding contracts to a full-fledged implementation of a programming
language reveals a number of subtle issues that studying small,
focused calculi cannot. In particular, our experience with Racket
alerted us to issues with proper blame assignment, interference
between the contracts and the program, and how supporting contracts
for advanced programming-language constructs leads to new, interesting
challenges.
</p>

<p>
In this talk I will report on contracts in Racket, showing how these
issues came up and how we resolved them. The talk will be structured
around a number of real-world examples, showing how Racket responds to
a series of increasingly complex interactions between modules with
contracts. The talk draws on work and experience from several PLT
institutions, including Northwestern, Northeastern, Utah, Brown, and
BYU.
</p>
</div>

        </div>

        <div class="col2">
          <a href="http://www.iro.umontreal.ca/%7Esfp2010"><img class="logo" src="logo.png" alt="SFP2010 logo"></a>

          <ul class="hidden">
            <li class="roomy"><a class="navigation" href=
            "index.html"><em>Home</em></a></li>

            <li class="roomy"><a class="navigation" href=
            "program.html"><em>Program</em></a></li>
            </li>

            <li class="roomy"><a class="navigation" href=
            "travel.html"><em>Travel information</em></a></li>
            </li>

            <li class="roomy"><a class="navigation" href=
            "registration.html"><em>Registration</em></a></li>

            <li class="roomy"><a class="navigation" href=
            "cfp.html">Call for papers</a></li>

            <li class="roomy"><a class="navigation" href=
            "submit.html">Paper submission</a></li>

            <li class="roomy"><a class="navigation" href=
            "http://schemeworkshop.org/">Past workshops</a></li>
          </ul>
        </div>
      </div>
    </div>

    <div style="clear: both;"></div>
  </div>
</body>
</html>
