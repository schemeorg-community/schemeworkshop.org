<?xml version="1.0" encoding="utf-8" ?>
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Scheme and Functional Programming Workshop 2006 - Report</title><link rel="stylesheet" type="text/css" href="main.css" media="all" /><link rel="stylesheet" type="text/css" href="main-print.css" media="print" /></head><body bgcolor="660000" link="#803060" vlink="#803060" alink="#803060"><table width="75%" align="center" valign="middle" bgcolor="FFFF99"><tr><td><table border="0" width="100%" bgcolor="red" cellpadding="1" cellspacing="1"><tr><td><table border="0" width="100%" bgcolor="orange" cellpadding="4" cellspacing="6"><tr><td><table width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td valign="top" align="left" valign="middle"><h1><font color="darkred">Scheme and Functional Programming 2006<br />in Portland OR, affiliated with <a href="http://icfp06.cs.uchicago.edu/">ICFP 2006</a></font><br /><font color="black">Report</font></h1></td><td align="right"><img src="s2005-logo.png" /></td></tr><tr><td colspan="2" align="right"><div class="navbar"><small><a href="index.html">report</a></small> | <small><a href="schedule.html">schedule</a></small> | <small><a href="dates.html">dates</a></small> | <small><a href="cfpapers.html">call for papers</a></small> | <small><a href="organizers.html">organizers</a></small> | <small><a href="past.html">other years</a></small></div></td></tr></table></td></tr></table></td></tr></table></td></tr><tr><td><br /><br /><center><b><a href="scheme2006.pdf">2006 Scheme and Functional Programming Papers,<br />University of Chicago TR-2006-06</a></b></center><br /><div class="summary"><table><tr bgcolor="660000"><td><table width="100%"><tr><td><a name="aselfhostingevaluatorusinghoas" /><table cellspacing="0" cellpadding="0" width="100%"><tr><td colspan="2"><font color="FFCC66"><b>A Self-Hosting Evaluator using HOAS</b></font></td></tr><tr><td><font color="FFCC66">Eli Barzilay (Northeastern University)</font></td><td valign="bottom" align="right"><a href="15-barzilay.pdf"><font color="999966">[pdf]</font></a></td></tr></table></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td><p>We demonstrate a tiny, yet non-trivial evaluator that is powerful enough to run practical code, including itself. This is made possible using a Higher-Order Abstract Syntax (HOAS) representation &mdash; a technique that has become popular in syntax-related research during the past decade. With a HOAS encoding, we use functions to encode binders in syntax values, leading to an advantages of reflecting binders rather than re-implementing them.</p><p>In Scheme, hygienic macros cover problems that are associated with binders in an elegant way, but only when extending the language, i.e., when we work at the meta-level. In contrast, HOAS is a useful object-level technique, used when we need to represent syntax values that contain bindings &mdash; and this is achieved in a way that is simple, robust, and efficient. We gradually develop the code, explaining the technique and its benefits, while playing with the evaluator.</p></td></tr></table></td></tr><tr><td>&nbsp;</td></tr><tr bgcolor="660000"><td><table width="100%"><tr><td><a name="fromvariadicfunctionstovariadicrelationsaminikanrenperspective" /><table cellspacing="0" cellpadding="0" width="100%"><tr><td colspan="2"><font color="FFCC66"><b>From Variadic Functions to Variadic Relations: A miniKanren Perspective</b></font></td></tr><tr><td><font color="FFCC66">William E. Byrd and Daniel P. Friedman (Indiana University)</font></td><td valign="bottom" align="right"><a href="12-byrd.pdf"><font color="999966">[pdf]</font></a></td></tr></table></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td><p>We present an implementation of miniKanren, an embedding of logic programming in R<sup>5</sup>RS Scheme that comprises three logic operators. We describe these operators, and use them to define <i>plus<sup>o</sup></i>, a relation that adds two numbers. We then define <i>plus*<sup>o</sup></i>, which adds zero or more numbers; <i>plus*<sup>o</sup></i> takes exactly two arguments, the first of which is a list of numbers to be added or a logical variable representing such a list. We call such a relation <i>pseudo-variadic</i>. Combining Scheme’s var-args facility with pseudo-variadic helper relations leads to <i>variadic</i> relations, which take a variable number of arguments. We focus on pseudo-variadic relations, which we demonstrate are more flexible than their variadic equivalents.</p><p>We show how to define <i>plus*<sup>o</sup></i> in terms of <i>plus<sup>o</sup></i> using <i>foldr<sup>o</sup></i> and <i>foldl<sup>o</sup></i>, higher-order relational abstractions derived from Haskell’s <i>foldr</i> and <i>foldl</i> functions. These higher-order abstractions demonstrate the benefit of embedding relational operators in a functional language. We define many other pseudo-variadic relations using <i>foldr<sup>o</sup></i> and <i>foldl<sup>o</sup></i>, consider the limitations of these abstractions, and explore their effect on the divergence behavior of the relations they define. We also consider <i>double-pseudo-variadic</i> relations, a generalization of pseudo-variadic relations that take as their first argument a list of lists or a logical variable representing a list of lists.</p></td></tr></table></td></tr><tr><td>&nbsp;</td></tr><tr bgcolor="660000"><td><table width="100%"><tr><td><a name="experienceswithschemeinanelectroopticslaboratory" /><table cellspacing="0" cellpadding="0" width="100%"><tr><td colspan="2"><font color="FFCC66"><b>Experiences with Scheme in an Electro-Optics Laboratory</b></font></td></tr><tr><td><font color="FFCC66">Richard Cleis and Keith Wilson (Air Force Research Laboratory)</font></td><td valign="bottom" align="right"><a href="08-cleis.pdf"><font color="999966">[pdf]</font></a></td></tr></table></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td><p>The Starfire Optical Range is an Air Force Research Laboratory engaged in Atmospheric Research near Albuquerque, New Mexico. Since the late 1980’s it has developed numerous telescope systems and auxiliary devices. Nearly all are controlled by C programs that became difficult to manage due to the large number of configurations required to support the experiments. To alleviate the problem, Scheme has been introduced in at least six distinct ways. This paper describes the uses of Scheme, emerging programming techniques, and general experiences of the past several years. </p></td></tr></table></td></tr><tr><td>&nbsp;</td></tr><tr bgcolor="660000"><td><table width="100%"><tr><td><a name="rapidcasedispatchinscheme" /><table cellspacing="0" cellpadding="0" width="100%"><tr><td colspan="2"><font color="FFCC66"><b>Rapid Case Dispatch in Scheme</b></font></td></tr><tr><td><font color="FFCC66">William D. Clinger (Northeastern University)</font></td><td valign="bottom" align="right"><a href="07-clinger.pdf"><font color="999966">[pdf]</font></a></td></tr></table></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td><p>The case expressions of Scheme can and should be implemented efficiently. A three-level dispatch performs well, even when dispatching on symbols, and scales to large case expressions.</p></td></tr></table></td></tr><tr><td>&nbsp;</td></tr><tr bgcolor="660000"><td><table width="100%"><tr><td><a name="astepperforschememacros" /><table cellspacing="0" cellpadding="0" width="100%"><tr><td colspan="2"><font color="FFCC66"><b>A Stepper for Scheme Macros</b></font></td></tr><tr><td><font color="FFCC66">Ryan Culpepper, Matthias Felleisen (Northeastern University)</font></td><td valign="bottom" align="right"><a href="10-culpepper.pdf"><font color="999966">[pdf]</font></a></td></tr></table></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td><p>Even in the days of Lisp’s simple <tt>defmacro</tt> systems, macro developers did not have adequate debugging support from their programming environment. Modern Scheme macro expanders are more complex than Lisp’s, implementing lexical hygiene, referential transparency for macro definitions, and frequently source properties. Scheme implementations, however, have only adopted Lisp’s inadequate macro inspection tools. Unfortunately, these tools rely on a naive model of the expansion process, thus leaving a gap between Scheme’s complex mode of expansion and what the programmer sees.</p><p>In this paper, we present a macro debugger with full support for modern Scheme macros. To construct the debugger, we have extended the macro expander so that it issues a series of expansion events. A parser turns these event streams into derivations in a natural semantics for macro expansion. From these derivations, the debugger extracts a reduction-sequence (stepping) view of the expansion. A programmer can specify with simple policies which parts of a derivation to omit and which parts to show. Last but not least, the debugger includes a syntax browser that graphically displays the various pieces of information that the expander attaches to syntactic tokens.</p></td></tr></table></td></tr><tr><td>&nbsp;</td></tr><tr bgcolor="660000"><td><table width="100%"><tr><td><a name="automaticconstructionofparsetreesforlexemes" /><table cellspacing="0" cellpadding="0" width="100%"><tr><td colspan="2"><font color="FFCC66"><b>Automatic construction of parse trees for lexemes</b></font></td></tr><tr><td><font color="FFCC66">Danny Dubé (Université Laval) and Anass Kadiri (EPITA, Paris France)</font></td><td valign="bottom" align="right"><a href="14-dube.pdf"><font color="999966">[pdf]</font></a></td></tr></table></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td><p>Recently, Dubé and Feeley presented a technique that makes lexical analyzers able to build parse trees for the lexemes that match regular expressions. While parse trees usually demonstrate how a word is generated by a context-free grammar, these parse trees demonstrate how a word is generated by a regular expression. This paper describes the adaptation and the implementation of that technique in a concrete lexical analyzer generator for Scheme. The adaptation of the technique includes extending it to the rich set of operators handled by the generator and reversing the direction of the parse trees construction so that it corresponds to the natural right-to-left construction of the lists in Scheme. The implementation of the adapted technique includes modifications to both the generation-time and the analysis-time parts of the generator. Uses of the new addition and empirical measurements of its cost are presented. Extensions and alternatives to the technique are considered.</p></td></tr></table></td></tr><tr><td>&nbsp;</td></tr><tr bgcolor="660000"><td><table width="100%"><tr><td><a name="concurrencyorientedprogrammingintermitescheme" /><table cellspacing="0" cellpadding="0" width="100%"><tr><td colspan="2"><font color="FFCC66"><b>Concurrency Oriented Programming in Termite Scheme</b></font></td></tr><tr><td><font color="FFCC66">Guillaume Germain, Marc Feeley, Stefan Monnier (Université de Montréal)</font></td><td valign="bottom" align="right"><a href="09-germain.pdf"><font color="999966">[pdf]</font></a></td></tr></table></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td><p>Termite Scheme is a variant of Scheme intended for distributed computing.  It offers a simple and powerful concurrency model, inspired by the Erlang programming language, which is based on a message-passing model of concurrency.</p><p>Our system is well suited for building custom protocols and abstractions for distributed computation.  Its open network model allows for the building of non-centralized distributed applications. The possibility of failure is reflected in the model, and ways to handle failure are available in the language.  We exploit the existence of first class continuations in order to allow the expression of high-level concepts such as process migration.</p><p>We describe the Termite model and its implications, how it compares to Erlang, and describe sample applications built with Termite.  We conclude with a discussion of the current implementation and its performance.</p></td></tr></table></td></tr><tr><td>&nbsp;</td></tr><tr bgcolor="660000"><td><table width="100%"><tr><td><a name="anincrementalapproachtocompilerconstruction" /><table cellspacing="0" cellpadding="0" width="100%"><tr><td colspan="2"><font color="FFCC66"><b>An Incremental Approach to Compiler Construction</b></font></td></tr><tr><td><font color="FFCC66">Abdulaziz Ghuloum (Indiana University)</font></td><td valign="bottom" align="right"><a href="11-ghuloum.pdf"><font color="999966">[pdf]</font></a></td></tr></table></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td><p>Compilers are perceived to be magical artifacts, carefully crafted by the wizards, and unfathomable by the mere mortals.  Books on compilers are better described as wizard-talk: written by and for a clique of all-knowing practitioners.  Real-life compilers are too complex to serve as an educational tool.  And the gap between real-life compilers and the educational toy compilers is too wide.  The novice compiler writer stands puzzled facing an impenetrable barrier, “better write an interpreter instead.”</p><p>The goal of this paper is to break that barrier.  We show that building a compiler can be as easy as building an interpreter.  The compiler we construct accepts a large subset of the Scheme programming language and produces assembly code for the Intel-x86 architecture, the dominant architecture of personal computing.  The development of the compiler is broken into many small incremental steps.  Every step yields a fully working compiler for a progressively expanding subset of Scheme.  Every compiler step produces real assembly code that can be assembled then executed directly by the hardware.  We assume that the reader is familiar with the basic computer architecture: its components and execution model. Detailed knowledge of the Intel-x86 architecture is not required.</p><p>The development of the compiler is described in detail in an extended tutorial.  Supporting material for the tutorial such as an automated testing facility coupled with a comprehensive test suite are provided with the tutorial.  It is our hope that current and future implementors of Scheme find in this paper the motivation for developing high-performance compilers and the means for achieving that goal.</p></td></tr></table></td></tr><tr><td>&nbsp;</td></tr><tr bgcolor="660000"><td><table width="100%"><tr><td><a name="sagehybridcheckingforflexiblespecifications" /><table cellspacing="0" cellpadding="0" width="100%"><tr><td colspan="2"><font color="FFCC66"><b>Sage: Hybrid Checking for Flexible Specifications</b></font></td></tr><tr><td><font color="FFCC66">Jessica Gronski (University of California, Santa Cruz (UCSC)), Kenneth Knowles (UCSC), Aaron Tomb (UCSC), Stephen N. Freund (Williams College), and Cormac Flanagan (UCSC)</font></td><td valign="bottom" align="right"><a href="06-freund.pdf"><font color="999966">[pdf]</font></a></td></tr></table></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td><p>Software systems typically contain large APIs that are informally specified and hence easily misused.  This paper presents the <font style="font-variant: small-caps">Sage</font> programming language, which is designed to enforce precise interface specifications in a flexible manner.  The <font style="font-variant: small-caps">Sage</font> type system uses a synthesis of the type <tt>Dynamic</tt>, first-class types, and arbitrary refinement types.  Since type checking for this expressive language is not statically decidable, <font style="font-variant: small-caps">Sage</font> uses <i>hybrid type checking</i>, which extends static type checking with dynamic contract checking, automatic theorem proving, and a database of refuted subtype judgments.</p></td></tr></table></td></tr><tr><td>&nbsp;</td></tr><tr bgcolor="660000"><td><table width="100%"><tr><td><a name="interactionsafestatefortheweb" /><table cellspacing="0" cellpadding="0" width="100%"><tr><td colspan="2"><font color="FFCC66"><b>Interaction-Safe State for the Web</b></font></td></tr><tr><td><font color="FFCC66">Jay McCarthy and Shriram Krishnamurthi (Brown University)</font></td><td valign="bottom" align="right"><a href="03-mccarthy.pdf"><font color="999966">[pdf]</font></a></td></tr></table></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td><p>Recent research has demonstrated that continuations provide a clean basis to describe interactive Web programs.  This account, however, provides only a limited description of state, which is essential to Web applications.  This state is affected by the numerous control operators (known as navigation buttons) in Web browsers, which make Web applications behave in unexpected and even erroneous ways.</p><p>We describe these subtleties as discovered in the context of working Web applications.  Based on this analysis we present linguistic extensions that accurately capture state in the context of the Web, presenting a novel form of dynamic scope.  We support this investigation with a formal semantics and a discussion of applications.  The results of this paper have already been successfully applied to working applications.</p></td></tr></table></td></tr><tr><td>&nbsp;</td></tr><tr bgcolor="660000"><td><table width="100%"><tr><td><a name="componentdeploymentwithplanetyouwantitwhere" /><table cellspacing="0" cellpadding="0" width="100%"><tr><td colspan="2"><font color="FFCC66"><b>Component Deployment with PLaneT: You Want it <i>Where?</i></b></font></td></tr><tr><td><font color="FFCC66">Jacob Matthews (University of Chicago)</font></td><td valign="bottom" align="right"><a href="04-matthews.pdf"><font color="999966">[pdf]</font></a></td></tr></table></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td><p>For the past two years we have been developing PLaneT, a package manager built into PLT Scheme’s module system that simplifies program development by doing away with the distinction between installed and uninstalled packages. In this paper we explain how PLaneT works and the rationales behind our major design choices, focusing particularly on our decision to integrate PLaneT into PLT Scheme and the consequences that decision had for PLaneT’s design. We also report our experience as PLaneT users and developers and describe what have emerged as PLaneT’s biggest advantages and drawbacks.</p></td></tr></table></td></tr><tr><td>&nbsp;</td></tr><tr bgcolor="660000"><td><table width="100%"><tr><td><a name="schemeforclientsidescriptinginmobilewebbrowsingorajaxlikebehaviorwithoutjavascript" /><table cellspacing="0" cellpadding="0" width="100%"><tr><td colspan="2"><font color="FFCC66"><b>Scheme for Client-Side Scripting in Mobile Web Browsing, or AJAX-Like Behavior Without Javascript</b></font></td></tr><tr><td><font color="FFCC66">Ray Rischpater (Rocket Mobile, Inc.)</font></td><td valign="bottom" align="right"><a href="02-rischpater.pdf"><font color="999966">[pdf]</font></a></td></tr></table></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td><p>I present an implementation of Scheme embedded within a Web browser for wireless terminals. Based on a port of TinyScheme integrated with RocketBrowser, an XHTML-MP browser running on Qualcomm BREW-enabled handsets. In addition to a comparison of the resulting script capabilities, I present the changes required to bring TinyScheme to Qualcomm BREW, including adding support for BREW components as TinyScheme data types. The resulting application supports the same kinds of dynamic client-side scripted behavior as a traditional Javascript-enabled Web browser in environments too memory constrained for a Javascript implementation.</p></td></tr></table></td></tr><tr><td>&nbsp;</td></tr><tr bgcolor="660000"><td><table width="100%"><tr><td><a name="shardaschemetohardwarecompiler" /><table cellspacing="0" cellpadding="0" width="100%"><tr><td colspan="2"><font color="FFCC66"><b>SHard: a Scheme to Hardware Compiler</b></font></td></tr><tr><td><font color="FFCC66">Xavier Saint-Mleux (Université de Montréal),  Marc Feeley (Université de Montréal) and Jean-Pierre David (École Polytechnique de Montréal)</font></td><td valign="bottom" align="right"><a href="05-saint-mleux.pdf"><font color="999966">[pdf]</font></a></td></tr></table></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td><p>Implementing computations in hardware can offer better performance and power consumption than a software implementation, typically at a higher development cost. Current hardware/software co-design methodologies usually start from a pure software model that is incrementally transformed into hardware until the required performance is achieved. This is often a manual process which is tedious and which makes component transformation and reuse difficult. We describe a prototype compiler that compiles a functional subset of the Scheme language into synthesizable descriptions of dataflow parallel hardware.  The compiler supports tail and non-tail function calls and higher-order functions.  Our approach makes it possible for software developers to use a single programming language to implement algorithms as hardware components using standardized interfaces that reduce the need for expertise in digital circuits. Performance results of our system on a few test programs are given for FPGA hardware.</p></td></tr></table></td></tr><tr><td>&nbsp;</td></tr><tr bgcolor="660000"><td><table width="100%"><tr><td><a name="invitedtalkthehopdevelopmentkit" /><table cellspacing="0" cellpadding="0" width="100%"><tr><td colspan="2"><font color="FFCC66"><b>Invited Talk: The HOP Development Kit</b></font></td></tr><tr><td><font color="FFCC66">Manuel Serrano (INRIA Sophia Antipolis)</font></td><td valign="bottom" align="right"><a href="01-serrano.pdf"><font color="999966">[pdf]</font></a></td></tr></table></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td><p>Hop, is a language dedicated to programming reactive and dynamic applications on the web. It is meant for programming applications such as web agendas, web galleries, web mail clients, etc. While a previous paper (<i>Hop, a Language for Programming the Web 2.0</i>, available at <a href="http://hop.inria.fr/">http://hop.inria.fr/</a>) focused on the linguistic novelties brought by Hop, the present one focuses on its execution environment. That is, it presents Hop’s user libraries, its extensions to the HTML-based standards, and its execution platform, the Hop web <i>broker</i>.</p></td></tr></table></td></tr><tr><td>&nbsp;</td></tr><tr bgcolor="660000"><td><table width="100%"><tr><td><a name="gradualtypingforfunctionallanguages" /><table cellspacing="0" cellpadding="0" width="100%"><tr><td colspan="2"><font color="FFCC66"><b>Gradual Typing for Functional Languages</b></font></td></tr><tr><td><font color="FFCC66">Jeremy G. Siek and Walid Taha (Rice University)</font></td><td valign="bottom" align="right"><a href="13-siek.pdf"><font color="999966">[pdf]</font></a></td></tr></table></td></tr></table></td></tr><tr><td><table cellspacing="0" cellpadding="0"><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td><p>Static and dynamic type systems have well-known strengths and weaknesses, and each is better suited for different programming tasks. There have been many efforts to integrate static and dynamic typing and thereby combine the benefits of both typing disciplines in the same language.  The flexibility of static typing can be improved by adding a type <font style="font-family: sans-serif">Dynamic</font> and a <font style="font-family: sans-serif">typecase</font> form. The safety and performance of dynamic typing can be improved by adding optional type annotations or by performing type inference (as in soft typing).  However, there has been little formal work on type systems that allow a programmer-controlled migration between dynamic and static typing.  Thatte proposed Quasi-Static Typing, but it does not statically catch all type errors in completely annotated programs. Anderson and Drossopoulou defined a nominal type system for an object-oriented language with optional type annotations.  However, developing a sound, gradual type system for functional languages with structural types is an open problem.</p><p>In this paper we present a solution based on the intuition that the structure of a type may be partially known/unknown at compile-time and the job of the type system is to catch incompatibilities between the known parts of types. We define the static and dynamic semantics of a &#955;-calculus with optional type annotations and we prove that its type system is sound with respect to the simply-typed &#955;-calculus for fully-annotated terms. We prove that this calculus is type safe and that the cost of dynamism is “pay-as-you-go”.</p></td></tr></table></td></tr><tr><td>&nbsp;</td></tr></table></div></td></tr></table></body></html>